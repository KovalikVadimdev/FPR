20221018190148       #учу/ФП
___ 
- "Функцiональне програмування" - "Функциональное программирование" (ФП)  
- [[ФП - Лаб-2]]
- [[ФП - UA - Лаб-2]]
___ 
## Функциональное программирование на Python 
___ 

- ... с использованием материала Википедии   ->   https://ru.wikipedia.org/wiki/Функциональное_программирование_на_Python 
- Функциональное программирование является одной из парадигм, поддерживаемых языком программирования Python. Основными предпосылками для полноценного функционального программирования в Python являются: функции высших порядков, развитые средства обработки списков, рекурсия, возможность организации ленивых вычислений. Элементы функционального программирования в Python могут быть полезны любому программисту, так как позволяют гармонично сочетать выразительную мощность этого подхода с другими подходами.
### Возможности
#### Определение и использование функции
- Функция в Python может быть определена с помощью оператора def или лямбда-выражением. Следующие операторы эквивалентны:
- ->  первый
```Python
def func(x, y):
    return x**2 + y**2
```
- ->  второй
```Python
func = lambda x, y: x**2 + y**2
```
- В определении функции фигурируют формальные аргументы. Некоторые из них могут иметь значения по умолчанию. Все аргументы со значениями по умолчанию следуют после аргументов без значений по умолчанию.
- При вызове функции задаются фактические аргументы. Например:
```Python
func(2, y=7)
```
- В начале идут позиционные аргументы. Они сопоставляются с именами формальных аргументов по порядку. Затем следуют именованные аргументы. Они сопоставляются по именам и могут быть заданы в вызове функции в любом порядке. Разумеется, все аргументы без значений по умолчанию должны быть заданы. Повторы в именах аргументов недопустимы.
- Функция всегда возвращает только одно значение (или None, если значение не задано в операторе return или этот оператор не встречен по достижении конца определения функции). Однако, это незначительное ограничение, так как возвращаемым значением может быть кортеж.
- Определив функцию с помощью лямбда-выражения, можно тут же ее использовать:
```Python
>>> (lambda x: x+2)(5)
7
```
- Лямбда-выражения удобны для определения не очень сложных функций, которые передаются затем другим функциям.
- Функции в Python являются объектами первого класса, то есть, они могут употребляться в программе наравне с объектами других типов данных.
#### Списочные выражения
- Списочные выражения (_list comprehension_, иногда используется термин «списковые включения») — наиболее выразительное из функциональных средств Python. Например, для вычисления списка квадратов натуральных чисел, меньших 10, можно использовать выражение:
```Python
I = [x**2 for x in range(10)]
```
#### Встроенные функции высших порядков
- В Python есть функции, одним из аргументом которых являются другие функции: map(), filter(), reduce(), apply().
##### map()
- Функция map() позволяет обрабатывать одну или несколько последовательностей с помощью заданной функции:
```Python
>>> list1 = [7, 2, 3, 10, 12]
>>> list2 = [-1, 1, -5, 4, 6]
>>> map(lambda x, y: x*y, list1, list2)
[-7, 2, -15, 40, 72]
```
- Аналогичного (только при одинаковой длине списков) результата можно добиться с помощью списочных выражений:
```Python
>>> [x*y for x, y in zip(list1, list2)]
[-7, 2, -15, 40, 72]
```
##### filter()
- Функция filter() позволяет фильтровать значения последовательности. В результирующем списке только те значения, для которых значение функции для элемента истинно:
```Python
>>> numbers = [10, 4, 2, -1, 6]
>>> filter(lambda x: x < 5, numbers)     # В результат попадают только те элементы x, для которых x < 5 истинно
[4, 2, -1]
```
- То же самое с помощью списковых выражений:
```Python
>>> numbers = [10, 4, 2, -1, 6]
>>> [x for x in numbers if x < 5]
[4, 2, -1]
```
##### reduce()
- Для организации цепочечных вычислений в списке можно использовать функцию reduce(). Например, произведение элементов списка может быть вычислено так:
```Python
>>> numbers = [2, 3, 4, 5, 6]
>>> reduce(lambda res, x: res*x, numbers, 1)
720
```
- Вычисления происходят в следующем порядке:
```Python
((((1*2)*3)*4)*5)*6
```
- Цепочка вызовов связывается с помощью промежуточного результата (res). Если список пустой, просто используется третий параметр (в случае произведения нуля множителей это 1):
```Python
>>> reduce(lambda res, x: res*x, [], 1)
1
```
- Разумеется, промежуточный результат необязательно число. Это может быть любой другой тип данных, в том числе и список. Следующий пример показывает _реверс_ списка:
```Python
>>> reduce(lambda res, x: [x]+res, [1, 2, 3, 4], [])
[4, 3, 2, 1]
```
- Для наиболее распространенных операций в Python есть встроенные функции:
```Python
>>> numbers = [1, 2, 3, 4, 5]
>>> sum(numbers)
15
>>> list(reversed(numbers))
[5, 4, 3, 2, 1]
```
- В Python 3 встроенной функции reduce() нет, но её можно найти в модуле functools.
##### apply()
- Функция для применения другой функции к позиционным и именованным аргументам, заданным списком и словарем соответственно:
```Python
>>> def f(x, y, z, a=None, b=None):
...     print x, y, z, a, b
...
>>> apply(f, [1, 2, 3], {'a': 4, 'b': 5})
1 2 3 4 5
```
- В последних версиях Python вместо функции apply() можно применить специальный синтаксис (в продолжение примера выше):
```Python
>>> f(*[1, 2, 3], **{'a': 4, 'b': 5})
1 2 3 4 5
```
##### Замыкания
- Функции, определяемые внутри других функций, представляют собой полноценные замыкания (англ. _closures_):
```Python
def multiplier(n):
    "multiplier(n) возвращает функцию, умножающую на n"
    def mul(k):
        return n*k
    return mul
# того же эффекта можно добиться выражением
# multiplier = lambda n: lambda k: n*k
mul2 = multiplier(2) # mul2 - функция, умножающая на 2, например, mul2(5) == 10
```
##### Итераторы
- Другие средства функционального программирования доступны из стандартной библиотеки (например, модуль itertools) и других библиотек.
- Следующий пример иллюстрирует применение перечисляющего и сортирующего итераторов (итератор не может быть напечатан оператором print, поэтому оставшиеся в нем значения были помещены в список):
```Python
>>> it = enumerate(sorted("PYTHON"))  # итератор для перечисленных отсортированных букв слова
>>> it.next()                         # следующее значение
(0, 'H')
>>> print list(it)                    # оставшиеся значения в виде списка
[(1, 'N'), (2, 'O'), (3, 'P'), (4, 'T'), (5, 'Y')]
```
- Следующий пример иллюстрирует использование модуля itertools:
```Python
>>> from itertools import chain
>>> print list(chain(iter("ABC"), iter("DEF")))
['A', 'B', 'C', 'D', 'E', 'F']
```
- В следующем примере иллюстрируется функция groupby (группировать по), с помощью которой порождается список пар значение ключа и соответствующий ключу итератор (в этот итератор собраны все значения исходного списка с одинаковым значением ключа). В примере ключом является True или False в зависимости от положительности значения. (Для целей вывода каждый итератор превращается в список).
```Python
from math import cos
from itertools import groupby
lst = [cos(x*.4) for x in range(30)]                       # косинусоида
[list(y) for k, y in groupby(lst, lambda x: x > 0)]        # группы положительных и отрицательных чисел
```
- В модуле itertools есть и другие функции для работы с итераторами, позволяющие кратко (в функциональном стиле) и с вычислительной точки зрения — эффективно — выразить требуемые процессы обработки списков.
##### Модуль functools
- В Python 2.5 появился модуль functools и в частности возможность _частичного применения функций_:
```Python
>>> from  functools import partial
>>> def myfun(a, b): return a + b
...
>>> myfun1 = partial(myfun, 1)
>>> print myfun1(2)
3
```
- (Частичное применение функций также можно реализовать с помощьюзамыканий илифункторов)
##### Ленивые вычисления
- Ленивые вычисления можно организовать в Python несколькими способами, используя различные механизмы:
	- простейшие логические операции or и and не вычисляют второй операнд, если результат определяется первым операндом
	- лямбда-выражения
	- определенные пользователем классы с ленивой логикой вычислений[[1] или функторы](#cite_note-lazypy-1)
	- Генераторы и генераторные выражения
	- (Python 2.5) if-выражение имеет «ленивую» семантику (вычисляется только тот операнд, который нужен)
- Пример, который иллюстрирует работу if-выражения. С помощью оператора print можно проследить, какие функции реально вызывались:
```Python
>>> def f():
...     print "f"
...     return "f"
...
>>> def g():
...     print "g"
...     return "g"
...
>>> f() if True else g()
f
'f'
>>> f() if False else g()
g
'g'
```
#### Функторы
- Функторами называют объекты, синтаксически подобные функциям, то есть поддерживающие операцию вызова.Для определения функтора нужно перегрузить оператор () с помощью метода __call__. ВPython функторы полностью аналогичны функциям, за исключением специальных атрибутов(func_code и некоторых других). Например, функторы можно передавать в качестве функцийобратного вызова (callback) в С-код. Функторы позволяют заменить некоторые приёмы, связанные с использованием замыкания, статических переменных и т. п.
- Ниже представлено замыкание и эквивалентный ему функтор:
```Python
def addClosure(val1):
    def closure(val2):
        return val1 + val2
    return closure
class AddFunctor(object):
    def __init__(self,val1):
        self.val1 = val1
    def __call__(self,val2):
        return self.val1 + val2
cl = addClosure(2)
fn = AddFunctor(2)
print cl(1), fn(1)  # напечатает "3 3"
```
- Следует отметить, что код, использующий замыкание, будет исполняться быстрее, чем код с функтором. Это связанно с необходимостью получения атрибута val у переменной self (то есть функтор проделывает на одну Python операцию больше).Также функторы нельзя использовать для создания декораторов с параметрами.С другой стороны, функторам доступны все возможности ООП в Python, что делает их очень полезными для функционального программирования. Например, можно написать функтор, который будет «запоминать» исполняемые над ним операции и затем повторять их.Для этого достаточно соответствующим образом перегрузить специальные метод
```Python
class SlowFunctor(object):
        def __init__(self,func):
                self.func = func
        def __add__(self,val):                  # сложение функтора с чем-то
                if isinstance(val,SlowFunctor): # если это функтор
                        new_func = lambda *dt,**mp : self(*dt,**mp) + val(*dt,**mp)
                else:                           # если что-то другое
                        new_func = lambda *dt,**mp : self(*dt,**mp) + val
                return SlowFunctor( new_func )
        def __call__(self,*dt):
                return self.func(*dt)
import math
def test1(x):
    return x + 1
def test2(x):
    return math.sin(x)
func = SlowFunctor(test1)                # создаем функтор
func = func + SlowFunctor(test2)         # этот функтор можно складывать с функторами
func = (lambda x : x + 2)(func)          # и числами, передавать в качестве параметра в функции
                                         # как будто это число
def func2(x):                            # Эквивалентная функция
    return test1(x) + test2(x) + 2
print func(math.pi)                      # печатает 3.14159265359
print func(math.pi) - func2(math.pi)     # печатает 0.0
```
- Функторы привносят в Python возможность ленивых вычислений, присущую функциональным языкам: вместо вычисления результата выражения — динамическое определение новых функций комбинированием имеющихся.
- Определенный подобным образом функтор создает значительные накладные расходы, так как при каждом вызовепроходит по вызовам всех вложенных lambda. Можно оптимизировать функтор,применив технику генерирования байткода во время исполнения. Соответствующий пример и тесты на скоростьесть в Примерах Python программ.При использовании этой техники скорость исполнения не будет отличаться от «статического» кода (если не считать времени, требующегося на однократное конструирование результирующей функции).Вместо байтокода Python можно генерировать на выходе, например, код на языке программированияC, других языках программирования или XML-файлы.
- Несмотря на накладные расходы, ленивое вычисление может дать заметный выигрыш в скорости в случаях, когда действия, оборачиваемые ленивым функтором, достаточно дороги — например, включают объёмные вычисления или доступ к диску. Предположим некоторый промежуточный результат _X_ лениво вычисляется перед условным оператором; для него будет создана цепочка функторов. В той ветке условного оператора, где значение _X_ не требуется по ходу вычисления, эта цепочка функторов будет просто отброшена, не приведя к дорогостоящему вычислению. В другой ветке, где _X_ требуется для вычисления конечного результата функции, цепочка функторов произведёт его вычисление. При этом программисту не нужно отслеживать, в какой из веток алгоритма значение может не потребоваться: он может рассчитывать, что дорогостоящее вычисление _X_ произойдёт только тогда, когда его результат не будет отброшен.
___ 
